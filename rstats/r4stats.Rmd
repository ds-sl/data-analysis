---
title: "R 統計解析"
author: "金城俊哉"
output: 
  html_notebook: 
    toc: yes
    toc_float: yes
    number_sections: yes
---

> R統計解析パーフェクトマスター（R4完全対応）［統計&機械学習 第2版］ （単行本）
> 出版社URL: https://www.shuwasystem.co.jp/book/9784798067728.html

R Notebook File for my personal learning created by DS-SL.

```{r}
library(tidyverse)
```


# Rと統計学
## データマイニングの時代だ
### データマイニングをすると何がトクなの？
#### データマイニングで成功をつかむ
#### データマイニングと統計学
### データマイニングのためのツール
#### Rって言語？ それともツール？
#### Rのイイところ
#### Rにはプログラミングするからこそのよさがあります
## RとRStudioをインストールしよう
### Memo Rのインストール（Macの場合）{-}
### Rをインストールし、続けてRStudioをインストールする
#### Rのダウンロードとインストール
#### Rを起動してみる
#### RStudioのダウンロードとインストール
### Memo Macでのインストール手順 {-}
### RStudioの起動と終了
#### RStudioの起動
#### RStudioの終了
### RStudioの設定
#### ホームディレクトリの設定
#### 作業ディレクトリの設定

# R の基本（RStudioの操作と基本プログラミング）
## RStudioでプログラムを実行する2つの方法（コンソールとソースファイル）
### RStudioを関数電卓みたいに使う（コンソールを利用したプログラムの実行）
#### 計算を行うソースコードを入力してその場で結果（答え）を見る
#### ソースコードは1文単位で実行
#### 処理結果は1行に収まらなければ複数の行にまたがって表示される
### ソースファイルにコードを書いて実行する
### Memo ［History］ビュー {-}
#### ソースファイルの保存
#### ソースファイルを開く
### プロジェクトの作成
#### プロジェクトを作成する
#### プロジェクトを開く
## Rの基本（データ操作）
### Rでデータを扱うときは「変数（オブジェクト）」が基本
#### とっておきたい値には名前を付けよう
#### 別の値に同じオブジェクト名を付ける

### データのかたち（データ型）
#### Rのデータ型は大きく分けて2つ
### データ操作のキホン、ベクトルを使いこなそう
#### ベクトルの作成
#### ベクトル要素の取り出しと置き換え
#### ベクトルの結合と挿入
#### ベクトルの要素に名前を付ける
#### ベクトル同士の演算


```{r}
a <- 50 + 50
a
b <- a
a
b

a <- 5
a
b

a <- 1
mode(a)
storage.mode(a)
class(a)

name <- "秀和太郎"
name
```


```{r}
# 数値型のベクトル
n1 <- c(2, 3, 4)
n1

# 文字列型のベクトル
chr1 <- c("おはよう", "こんにちは", "わんばんこ")
chr1

# ベクトルを削除する
rm(n1)
rm(chr1)
```

```{r eval=FALSE}
n1
```
```{r eval=FALSE}
chr1
```

```{r}
# ベクトルの長さ
x <- c(10, 20, 30, 40, 50)
length(x)

# 要素の取り出し
vec <- c(10, 20)
vec
vec[1]
vec[2]
vec[3]

x <- c(10, 20, 30, 40, 50)
x[2:4]

x[c(1, 3, 5)]
x[-1]
x[c(-1, -3, -5)]
x[30 < x]
x[30 > x]
x[10 < x & 40 > x]

# 要素の置き換え
x[5] <- 0
x
x[5] <- "hello"
x

# ベクトルの結合
x <- c(1, 2, 3); y <- c(4, 5, 6); z <- c(7, 8, 9)
a <- c(x, y, z)
a
b <- append(x, y)
b
c <- append(b, y, after=3)
c

# ベクトルの要素に名前を付ける
num <- c(1, 2, 3, 4, 5, 6)
names(num) <- c("one", "two", "three", "four", "five", "six")
num

names(num)
num["one"]

# 名前属性の操作
names(num) <- c("num1", "num2", "num3", "num4", "num5", "num6")
num

names(num) <- NULL
num

# ベクトルの演算
x <- c(1, 2, 3); y <- c(1, 2, 3)
z <- x + y
z

z <- x * y
z

x <- c(100, 100, 200, 200); y <- c(0.1, 1.1)
z <- x * y
z

price <- c(1000, 2000, 3000)
tax_in <- price * 1.1
tax_in

# 規則性のあるベクトルの作成
x <- 1:5
x

y <- 5:-5
y

a <- rep(1:3, length=9)
a

# データ型を調べる
chr <- "R"
is.numeric(chr)
is.character(chr)

# データ型の変換
data1 <- c("1.23", "20.34", "300.45")
mode(data1)
conv1 <- as.numeric(data1)
mode(conv1)
storage.mode(conv1)
conv1
conv1 <- as.integer(conv1)
mode(conv1)
storage.mode(conv1)
conv1
```

### Memo 規則性のあるベクトルの作成 {-}
### Hint データ型が何かを調べる {-}
### データ型の変換
#### 関数を使ってデータ型を変換する
### リスト
#### リストの要素を取り出す
#### リスト要素のベクトルの要素を取り出す
#### リスト要素を「名前＝値」のペアで管理する

```{r}
# リストの作成---------------------------------
# 顧客のidをベクトルに格納
id <- c(101, 102, 103)
# 顧客名をベクトルに格納
name <- c("秀和太郎",
          "秀和花子",
          "宗田解析")
# 住所をベクトルに格納
address <- c("東京都江東区東陽2",
            "東京都江東区東陽2-4",
            "東京都中央区銀座100")
# 顧客情報をまとめたリストを作成
customer <- list(id, name, address)
# customerの構造を出力
str(customer)

# リストの要素をリストとして取得
list1 <- customer[1] # リストの第1要素を取得
list2 <- customer[2] # リストの第2要素を取得
list3 <- customer[3] # リストの第3要素を取得
# 出力
list1
list2
list3
class(list1)
class(list2)
class(list3)

# リストの要素を取得
element1 <- customer[[1]] # リストの第1要素を取得
element2 <- customer[[2]] # リストの第2要素を取得
element3 <- customer[[3]] # リストの第3要素を取得
# 出力
element1
element2
element3
class(element1)
class(element2)
class(element3)

# リストの第1要素のベクトルから第1要素を取り出す
vector1_2 <- customer[[1]][1]
vector1_2
class(vector1_2)

# リスト要素のベクトルの要素を取り出す
id_1 <- customer[[1]][1]     # 一人目のid
name_1 <- customer[[2]][[1]] # 一人目の名前
addr_1 <- customer[[3]][[1]] # 一人目の住所
# データ型と値を出力
str(id_1)
str(name_1)
str(addr_1)

# customerの第1要素を変更する
customer[[1]] <- c(1, 2, 3)
# 出力
customer

# customerの第1要素のベクトルの第3要素を変更する
customer[[1]][3] <- 333
# 出力
customer
```

```{r}
# リストの要素に名前を付ける
customer <- list(
  id = c(101, 102, 103),
  name = c("秀和太郎",
           "秀和花子",
           "宗田解析"),
  address = c("東京都江東区東陽2",
              "東京都江東区東陽2-4",
              "東京都中央区銀座100")
  )
# リストを出力
customer

# リスト["要素名"]でリストとして取り出す
customer["id"]
# リスト[["要素名"]]で要素を取り出す
customer[["id"]]
# idの第1要素を取り出す
customer[["id"]][1]
# リスト$要素名とすると要素が取り出される
customer$id
# idの第1要素を取り出す
customer$id[1]
```


### 行列（マトリックス）
#### 行列は（行，列）の集計表
### Hint 配列 {-}

```{r}
# ベクトルを用意
vct1 <- c(1, 2, 3, 4, 5, 6)
vct2 <- c(10, 20, 30, 40, 50, 60)
vct3 <- c(100, 200, 300, 400, 500, 600)
# (3行,2列)の行列を3個作成
mtx1 <- matrix(c(1, 2, 3, 4, 5, 6), ncol=2)
mtx2 <- matrix(c(10, 20, 30, 40, 50, 60), ncol=2)
mtx3 <- matrix(c(100, 200, 300, 400, 500, 600), ncol=2)
array1 <- array(
  c(mtx1, mtx2, mtx3), # vct1、vct2、vct3を1つのベクトルにする
  dim=c(3,2,3)         # 行数3、列数2、行列の数3を指定
)
# 配列の中身を出力
array1
# 3次元のインデックスのみを指定して1つ目の行列を抽出
array1[, , 1]
```

```{r}
# ベクトルを用意する
vct1 <- c(1, 2, 3, 4, 5, 6)
vct2 <- c(10, 20, 30, 40, 50, 60)
vct3 <- c(100, 200, 300, 400, 500, 600)

mtx1 <- matrix(vct1)             # 行列(縦ベクトル)を作成
mtx1                             # 出力

mtx2 <- matrix(vct1, nrow=2)     # 2行の行列を作成
mtx2                             # 出力

mtx3 <- matrix(vct1, ncol=2)     # 2列の行列を作成
mtx3                             # 出力

mtx4 <- matrix(vct1, 2,2)        # (2行,2列)の行列を作成
mtx4                             # 出力

mtx5 <- matrix(
  c(vct1, vct2, vct3), # vct1, vct2, vct3を1つのベクトルにする
  nrow=3,              # 2行の行列
  byrow = TRUE)        # 値を行方向に並べる
mtx5                   # 出力

mtx6 <- rbind(vct1, vct2, vct3)  # 3つのベクトルを行方向に連結する
mtx6                             # 出力

colSums(mtx6)                    # 列の合計を求める

rowSums(mtx6)                    # 行の合計を求める

mtx7 <- cbind(vct1, vct2, vct3)  # 3つのベクトルを列方向に連結する
mtx7                             # 出力

mtx7[1,]   # 1行目を取り出す
mtx7[,1]   # 1列目を取り出す
mtx7[1,1]  # 1行目の1列目の値を取り出す
```


### データフレーム
#### データフレームの作成

```{r}
# 店舗名を格納したベクトル
branch <- c(
  "初台店", "幡谷店", "吉祥寺店", "笹塚店", "明大前店")
# 各店舗の売上額(千円)を格納したベクトル
sales <- c(2024, 2164, 6465, 2186, 2348)
# データフレームを作成
df <- data.frame(branch=branch, # 列1
                 salses=sales)  # 列2

df$branch # 列データを要素として取り出す
df[[1]]   # 列データを要素として取り出す
df[,1]    # 列データを要素として取り出す
df[1]     # 列データをデータフレームとして取り出す
df[1:2]   # 指定した範囲の列をデータフレームとして取り出す

df[1,]    # 行データをデータフレームとして取り出す
df[1:3,]  # 指定した範囲の行をデータフレームとして取り出す

df[1,1]   # 特定の要素を取り出す
```

### Memo コメントについて {-}
#### データフレームから列や行のデータを取り出す
#### 外部ファイルのデータをデータフレームに取り込む
#### タブ区切りのテキストファイルをデータフレームに読み込んでみよう

```{r}
# タブ区切りの店舗別売上.txtをデータフレームに読み込む
data <- read.table(             
  "data/店舗別売上.txt",    # ファイル名
  header=TRUE,         # 1行目は列名であることを指定
  fileEncoding="UTF-8" # 文字コードをUTF-8に指定
)
data
```

### Tips Excelのデータをクリップボード経由で読み込む {-}

Don't run the following code.

```{r eval=FALSE}
# クリップボードにコピーしたデータをデータフレームに読み込む
data <- read.table("clipboard", # ファイル名を"clipboard"にする
                   header=TRUE) # データの1行目を列名として設定
```

The above code does not work for Mac and probably for Linux using X11. Use the following.

```{r}
data <- read_delim(clipboard())
data
```


## プログラムの制御と関数（制御構造と関数）
### 「もしも」で処理を分ける（ifステートメント）
#### 　ifステートメントの書き方

```{r}
# numに負の値を代入
num <- -10

if(num < 0){
  # numが負の値であれば-1を掛けて正の値にする
  num <- num * -1
}

# numの値を出力
num
```

#### 「そうでなければ」を実行するelse if／else

```{r}
# numに正の値を代入
num <- 10

if(num < 0) {
  # numが負の値なら-1を掛けて正の値にする
  num <- num * -1 
} else if(num > 0) {
  # numが正の値なら-1を掛けて負の値にする
  num <- num * -1
}

# numの値を出力
num
```

```{r}
# numに文字列を代入
val <- "-10"
if(is.numeric(val) & val < 0){
  # valが実数型かつ負の値なら-1を掛けて正の値にする
  n <- n * -1
} else if (is.numeric(val) & val > 0) {
  # nvalは実数型かつ正の値なら-1を掛けて負の値にする
  val <- val * -1
} else {
  # どの条件も成立しない場合はnumeric型に変換する
  val <- as.numeric(val)
}

# valの情報を出力
str(val)
```

### 同じ処理を繰り返す（forステートメント）
#### 指定した回数だけ処理を繰り返す

```{r}
# 定着度.txtをデータフレームに読み込む
data <- read.table(    
  "data/定着度.txt",
  header=T,            # 1行目は列名
  fileEncoding="UTF-8" # 文字コードはUTF-8
)

# データフレームの1行目(列名の次行)を指定して
# 列の数を調べる(4列)
j <- length(data[1,])

# イテレート可能なオブジェクトc(1:j)で1列～4列を順に処理
for(i in c(1:j)) {
  # 連番を付けたオブジェクトを生成して列データを代入
  assign(
    sprintf("x%d", i), # ベクトル名はx1、x2、x3、x4
    data[,i]           # データフレームの1列目から代入
  )
}
```

```{r}
data
```


### 決まった処理に名前を付けて呼び出せるようにしよう（関数の作成）
#### 処理だけを行う関数

```{r}
# 処理だけを行う関数
show <- function() {
  print("Hello!")
}
# 関数を呼び出す
show()
```

#### 引数を受け取る関数

```{r}
# パラメーターが設定された関数
showParameter <- function(word_1, word_2) {
  print(word_1) # word_1を出力
  print(word_2) # word_2を出力
}

# 引数を指定して関数を呼び出す
showParameter("Rの世界へ", "ようこそ！")
```

#### 戻り値を返す関数

```{r}
# 引数を受け取って戻り値を返す関数
calculateTax <- function(val) {
  tax_in <- val * 1.1 # valに1.1を掛ける
  return(tax_in)      # tax_inを戻り値として返す
}

# 引数を指定して関数を呼び出す
calculateTax(100)
```

#### 作成した関数を他のソースファイルから実行できるようにしよう

```{r eval = FALSE}
# タブ区切りのテキストファイルをデータフレームに読み込む関数
# Parameter:
#   path: ファイル名またはファイルパス
load.file <- function(path) {
  # ファイルを読み込んでデータフレームに格納
  data <- read.table(    
    path,                # 読み込むファイル
    header=T,            # 1行目は列名を指定
    fileEncoding="UTF-8" # 文字コードをUTF-8に指定
  )
  # データフレームを戻り値として返す
  return(data)
}
```


```{r}
# load-file.Rを読み込む
source("data/load-file.R", encoding="utf-8")

# ファイル名を引数にしてload.file()関数を呼び出す
data <- load.file("data/店舗別売上.txt")
```

```{r}
data
```


### Memo RStudio {-}

# データの全体像を解析する（代表値）
## データをならして出てくる代表値（平均）
### 平均を求める
#### 平均値を求める式
## データの分布を棒グラフで見やすくしよう（ヒストグラム）
### 度数分布表筐｡ヒストグラムの作成こそが統計の第一歩
#### ヒストグラムは「階級の幅」を決めて「階級」を作る
## 階級幅を独自に指定したヒストグラムを作る
### 階級幅や棒グラフの色を指定してヒストグラムを作成する
#### 最小値と最大値を調べてヒストグラムの下限値と上限値を決定する（手順①～②）
#### ヒストグラムの作成（手順③）
#### コードを入力してヒストグラムを作成してみる
### Memo 階級の幅 {-}
#### ヒストグラムの山は1つか2つ以上か
## 度数分布表から相対度数分布表を作る
### 相対度数分布表を作る
#### 度数分布表を作成し、これをもとに相対度数分布表を作成する
#### 相対度数を棒グラフにしてみる
#### 相対度数分布表を作成する関数を定義する
## 平均の足を引っ張るデータを除外する（トリム平均）
### 平均は真ん中くらいの値ではなかった
#### mean()関数のオプションを使って「トリム平均」を求める
## しっくりこないならど真ん中の値を見付けよう（中央値）
### 平均とは違う、データの「ど真ん中」の値
#### 散らばったデータのど真ん中を指す中央値
#### summary()関数で最大、最小、平均、中央値をまとめて調べる

# データのバラツキ具合を知る（偏差、分散、標準偏差）
## データのバラツキ具合を数字で表す（偏差、分散）
### Memo 分散と不偏分散 {-}
### 個々のデータの平均との差を調べて全体の散らばり具合を知る
#### 平均からどのくらい離れているのかを表すのが「偏差」
#### 偏差を求める
### 偏差を2乗した「偏差平均」を平均して「分散」を求める
#### 偏差平方の平均が「分散」
### Hint データに手を加えると平均、分散はどうなる？ {-}
## そのデータは「優秀」なのかそれとも「普通」？（標準偏差）
### Memo 平均や分散、標準偏差の記号について {-}
### 新規オープン店の売上数は突出しているのか
#### 分散をデータの単位に戻して比較できるようにする
### データの特殊性を「標準化」した数値で表す
#### 商品Aと商品Bの販売数をすべて標準化する
### Memo 平方根について {-}
## 来客数が平均より多いのは「繁盛」しているといえるか
### 標準偏差を「尺度」にする
#### 来客数の標準偏差と標準化係数を求める
### データの偏差が標準偏差の±1個ぶんの範囲内であれば平凡なデータだと判断できる
#### 標準化係数でデータの特殊性を知る
#### 標準化した値の平均は0で標準偏差は1
## 来店者の数が上位5％に入る日を調べる
### 正規分布のグラフの形は平均と標準偏差で決まる
#### 標準正規分布のグラフ
#### 確率密度関数
### 標準正規分布のグラフ中の区切られた領域がデータの出現率を表す
#### 標準正規分布の数表をRで作成してみる
#### Rで標準正規分布の数表を作成する
#### 標準正規分布の数表の見方
### 上位5％に入る来店者数を見付けよう
#### 標準正規分布の数表を使って上位5％の区間面積に対するxの値を求めよう

# 正規分布するデータを解析する
## 売上の平均が38万円のとき45万円以上売上げる確率は？
### Hint 数学定数の「ネイピア数」{-}
### 標準正規分布ではないふつうの分布は「一般正規分布」
#### 正規分布をσ＝1、μ＝0に換算して標準正規分布にする
#### 正規分布のxを求める確率密度関数f(x)
#### Onepoint ××万円以上○○万円以下の売上が発生する確率は？
### 売上が40万円以上になる確率を求めてみよう
#### 30万～60万円を5万円刻みにして、それぞれの累積確率を求める
## 偏差値の仕組み
### 標準化した値を10倍にして50を足すのは何のためか
#### 偏差値を求めてみる
### 標準偏差を用いた合格判定の仕組み
#### 平均と標準偏差、あとはデータの数で合否を推測する
## バラバラに分布するデータを正規分布に近似する（大数の法則）
### 1000人ぶんのサンプルで10万人ぶんの相対度数分布グラフが描かれる
#### 10万人の中から1人ずつ選んで1000回計測したらどうなる？（復元抽出）
#### 非復元抽出と復元抽出
### Hint 相対度数分布グラフはなぜ曲線の山の形をしている？{-}
## 正規分布の再生性
### 正規分布は2つを重ねても分布の形が保存される
#### 正規分布の再生性
### Memo 「大数の法則」でサンプルの相対度数分布が母集団のデータとぴったり一致！{-}
### Memo 中心極限定理 {-}
## ピンポイントでズバリ当てる（点推定）
### 母集団と標本
#### 全数調査と標本調査
#### 無作為抽出（ランダムサンプリング）
### ピンポイントで推定する
#### 最尤法による推定
#### 不偏推定量による推定
#### 点推定の結果を見る
## サイコロを振ると1の目が出る確率は？
### 確率変数とその定義
#### 偶数の目が出る確率は
### Hint 離散と連続の違いは？ {-}
#### 確率の定義
#### 離散型一様分布の確率質量関数
#### サイコロを振ると本当に6分の1の確率で各目が出るのか
## 「標本平均の平均」をとると母平均にかなり近くなる
### 母集団から5個のサンプルをランダムに抽出する
#### sample()関数によるランダムサンプリング
#### 母集団の平均と標本の平均
#### 標本分布で推定するときのポイント2つ
### 標本分布が母集団の本当の値を中心として分布しているか
#### 標本平均の数が大きくなると標本分布が正規分布に近くなっていく
#### 標本平均の分散と標準誤差を確認する
### サンプルサイズを大きくすると標準誤差は本当に小さくなるのか
#### サンプルサイズを5から20にする
## データ全体の散らばりと標本平均の散らばり
### 標本平均の分散を調べる
#### 標本平均の分散と母分散の関係を調べる
## 標本分散の平均
### 標本分散の代わりに不偏分散を推定値として使う
#### 標本分散と不偏分散のそれぞれの平均を母分散と比較する
#### 母集団と標本の関係のまとめ

# 手持ちのデータで全体を知る（標本と母集団）
## 大標本を使って全体の平均を予測する（z値を用いた区間推定）
### 降水確率に見る区間推定の考え方
#### 区間推定の考え方
#### 信頼区間と信頼度
### Memo 信頼度95％の区間推定 {-}
### 信頼度95％で母平均を区間推定する
#### 大標本（サンプルサイズ30以上）の信頼区間
#### 母平均の信頼区間の関係式を導く
#### サンプルサイズ50で母平均を区間推定する
## 小標本を使って全体の平均を予測する（t値を用いた区間推定）
### 小標本による平均値の推定
#### 小標本の平均と分散を用いて母平均の信頼区間を求める
#### Onepoint 自由度
### 信頼度95％で母平均を区間推定する
#### 小標本による区間推定の結果
## 母集団のデータの比率を区間推定する
### 二項分布の確率理論を用いて母集団の割合を推定する
#### 離散型の代表的かつ重要な確率分布である「二項分布」
#### 二項分布の試行回数を無限大にすると正規分布になる
### Memo 順序を考慮する場合の数は「順列」{-}
### 母集団の「比率」を区間推定する
#### 母比率を95％の信頼度で区間推定する
#### 支持率45％と47％に「差はある」のか
### Hint 自由度が30を超えると標準正規分布とほぼ同じになる{-}
### Memo 階乗{-}

# 独立性の検定と2つの平均の比較（χ2検定、t検定）
## 2つのデータの独立性の検定（カイ二乗検定）
### データの分布を検証するカイ二乗検定
#### サイコロを投げて1から6までの目が出る確率
#### サイコロ投げの結果をカイ二乗検定で調べる
#### 検定に使用する検定統計量を求める式
#### 自由度
#### サイコロ投げ12回の試行結果をχ2検定する
#### χ2検定を行う手順
### Memo 対立仮説と帰無仮説 {-}
### Memo 有意水準 {-}
### A店とB店のデータ分布は同じかどうかを判断する
#### 「差はない」という帰無仮説を立ててχ2検定を実施
#### A店とB店の売上に差はあるのか
## 独立した2群の差のt検定①
#### （分散が等質と仮定できる場合のt検定）
### 独立した2群における3つのt検定
#### 独立した2群のt検定
### スチューデントのt検定で母平均を検定する
#### 検定に使用する検定統計量tの求め方
### Hint σ2を求める式について {-}
### 検定統計量と有意水準5％のt値を求める
#### ライバル店の平均点との差はあるのか
#### 　p値を求めてt検定を行う
#### 　t.test()関数で検定統計量tを求める
## 独立した2群の差のt検定②
#### （分散が等しいと仮定できない場合のウェルチのt検定）
### ウェルチのt検定で、母分散が等しくない2群の平均を検定する
#### 独立した2群の分散が等しいことを前提にしないウェルチのt検定
### ウェルチのt検定を実施する
### Hint t検定のデフォルトはウェルチのt検定{-}
## 対応のある2群の差のt検定
### 対応のある2群の差のt検定は変化量（変量の差）の平均値の検定になる
#### 検定統計量tの式
### 検定を実施して平均に差があるのかを判定する
#### 検定統計量の実現値を求める
#### 平均体重の変化に統計的な差は認められるのか
#### p値を求めてt検定を行う
#### t.test()関数で検定統計量tの実現値を求める
### Memo RStudioの［Packages］ビュー {-}

# 3つの平均値が同じ土俵で比較できるか調べる（t検定が使えない場合の分散分析）
## 1要因の分散分析①（対応なし）
### t検定は3つ以上の平均の差の検定には使えない
#### t検定が3つ以上の平均の差の検定に使えない理由
### 3つの平均に差があるかを分散分析で調べる
#### 分散分析に使用する検定統計量
### Memo 分散分析 {-}
### Tips 分子の自由度6、分母の自由度18のF分布をグラフにする{-}
### 1要因の分散分析（対応なし）を実施する
#### 分散分析のためのデータを用意する
#### oneway.test()関数で検定統計量とp値を求める
#### aov()関数で検定統計量の実現値とp値を求める
#### anova()関数で検定統計量の実現値とp値を求める
### 分散分析を理解する
#### 「群間のズレ」と「群内のズレ」
#### 標本平均間のズレと標本内部のデータのズレを見る
### 多重比較（Tukeyの方法）
#### RのTukeyHSD()関数で多重比較を行ってみる
## 1要因の分散分析②（対応あり）
### 対応がある1要因の分散分析の実施
#### 分散分析の実施
### 対応ありとなしで違いが出たのはなぜ？
#### 対応なしと対応ありによる違いを見る
#### 平方和を分解して自由度を計算してみよう
## 2要因の分散分析①（2要因とも対応なし）
### 主効果と交互に作用する効果
#### 主効果と交互作用効果について
### 2要因の分散分析（対応なし）を実施する
#### 2要因の分散分析（対応なし）の実施
#### 帰無仮説の棄却／採択の決定
#### 交互作用効果を確認する
## 2要因の分散分析②（2要因とも対応あり）
### 2要因の分散分析（対応あり）を実施する
#### 2要因の分散分析（対応あり）の実施
#### Onepoint 2要因の分散分析（対応あり）を行ったあとは
## 2要因の分散分析③（1要因のみ対応あり）
### 2要因の分散分析（1要因のみ対応あり）を実施する
#### 2要因の分散分析（1要因のみ対応あり）の実施
#### 帰無仮説の棄却／採択の決定
### Hint 帰無仮説と対立仮説 {-}

# 回帰分析で未来を知る（単回帰分析と重回帰分析）
## 清涼飲料水の売上と気温の関係（相関関係と線形単回帰分析）
### データ間の相関関係を分析する
#### 相関分析でデータ同士の関係性を数値化する
### Hint 相関分析のポイントと注意点 {-}
### 散布図で相関関係を見る（散布図の描画）
#### 散布図の作成
### 2つのデータの関係の強さを求める（相関係数の計算）
#### 2つのデータの相関係数を求める
### Memo シグマの記号について {-}
### 線形回帰分析を実行する
#### 回帰式における回帰係数と定数項を求める
#### 回帰係数と共分散の関係を見る
#### Im()関数で線形回帰分析を行う
### 最高気温が1℃上昇したときの売上数を予測する
#### 回帰直線を散布図上に表示してみる
#### 最高気温が30℃、31℃、さらに36℃のときの売上数を予測する
### Memo 回帰分析の手法 {-}
### Memo 内挿と外挿 {-}
### Tips 分析の元データと予測値、残差を一覧で表示する {-}
## 立地、面積、競合店とアンケート結果から売上を予測する
#### （線形重回帰分析）
### 重回帰分析で説明変数が複数の場合の分析を行う
#### 2つ以上の要因を使って予測を行う重回帰分析
#### 予測値を示す重回帰分析の式とは
#### 相関係数を確認する
### すべての説明変数を使って重回帰分析する
#### データにあるすべての説明変数を重回帰分析にかける
#### 分析結果の見るべきポイントは3つ
### 説明変数を減らしてもう一度分析する
#### step()関数で説明変数を1つずつ減らした分析結果を見る
### Hint 多重共線性 {-}
#### 2つの説明変数を減らして重回帰分析を実行する
### 説明変数を減らさずに変数の交互作用だけを減らして分析する
#### 交互作用を考慮した回帰係数を求める
#### step()関数でAICが最も低い組み合わせを調べる
## 急激に上昇カーブを描く普及率を予測する（非線形回帰分析）
### ロジスティック関数を使って非線形回帰分析をする
#### 非線形の回帰分析をロジスティック回帰で行う
### Tips ロジスティック回帰 {-}
### データにロジスティック関数を当てはめて非線形回帰分析をする
#### nls()関数の関係式にロジスティック関数を指定して分析する
### SSlogis()関数を使って非線形回帰分析をする
#### ロジスティック関数SSlogis()で曲線を割り出す
## 日射量、風力、温度の値でオゾンの量を説明する
#### （一般化線形モデル）
### 一般化線形モデルの回帰分析を行うglm()関数
#### 一般化線形モデルとglm()関数
#### 関数glm()
### 一般化線形モデルの回帰分析
#### 今回のケースで線形回帰分析をするとどうなる？
#### glm()関数で一般化線形モデルの回帰分析を行う
## モルモットの実験データから、ビタミンCを何で与えたかを予測する
### ロジット関数を用いた二値分類
#### ロジット関数
### ロジット関数で二値分類を行う
### Tips ロジット関数の逆関数はシグモイド関数 {-}

# クラスター分析
## バラバラに散らばるデータを統計的に整理しよう
#### （階層的クラスター分析）
### データを統計的な考え方でグループ分けするのがクラスター分析
#### 階層的クラスター分析
#### 階層的クラスター分析のプロセス
#### データ行列を作って距離行列を作る（分析のプロセス①～②）
#### 距離行列からコーフェン行列を作る（分析のプロセス③）
### 階層的クラスター分析で他の方法を試してみる
#### クラスタリングの過程を見てみる
### Tips 大量のデータを的確にグループ分けする {-}

# Rで機械学習
## 機械学習のワークフロー
#### Onepoint カテゴリデータの変換
### 機械学習を進める手順
### 特徴量エンジニアリング（データの前処理）
### 機械学習におけるモデルの評価方法
#### MSE（平均二乗誤差）
#### RMSE（平均二乗平方根誤差）
#### RMSLE（対数平均二乗平方根誤差）
#### MAE（平均絶対誤差）
#### 決定係数（R2）
### 機械学習で用いられるアルゴリズム
## 「ボストン住宅価格」の予測
### 「Boston Housing」データセット
#### Onepoint rsampleのインストール
### 線形重回帰で住宅価格を予測する
#### データを用意する
#### 線形重回帰分析で住宅価格を予測する
## Ridge回帰、Lasso回帰で住宅価格を予測する
### 線形回帰の正則化
### リッジ回帰
### データを用意する処理をまとめたソースファイルを作成する
### リッジ回帰で予測する
### バリデーション
#### バリデーションの手法
#### Onepoint glmnetのインストール
### ラッソ回帰
### ラッソ回帰で住宅価格の中央値を予測する
### エラスティックネット
### エラスティックネットで住宅価格の中央値を予測する
## 線形サポートベクター回帰
### サポートベクター回帰
#### 線形サポートベクター回帰
### サポートベクター回帰で住宅価格の中央値を予測する
### Memo サポートベクターマシンのカーネル {-}
#### Onepoint kernlabのインストール
## ランダムフォレスト回帰
### 決定木とランダムフォレスト回帰
#### 「決定木」というアルゴリズム
#### 　ランダムフォレスト
### ランダムフォレスト回帰で住宅価格の中央値を予測する
#### 　Onepoint randoｍForestのインストール
## 「Wine Quality」データセットを利用した分類
### 「Wine Quality」データセット
## サポートベクターマシンによる分類
### サポートベクターマシンによる分類
#### マージンとサポートベクターによる分類
### サポートベクターマシンでワインの評価を分類する
## 「決定木」による分類
### 「決定木」による分類
### 「決定木」でワインの評価を分類する
### Memo 勾配ブースティング {-}
## ランダムフォレストによる分類
### ランダムフォレストによるワインの分類
## ニューラルネットワークによる分類
### ニューラルネットワークによる分類
#### ニューラルネットワークのニューロン
#### 学習するということは、重み・バイアスを適切な値に更新するということ
#### 順方向で出力し、間違いがあれば逆方向に向かって修正して1回の学習を終える
#### Onepoint 多クラス分類
#### ニューラルネットワークにおける順伝播処理
#### 勾配降下法によるパラメーターの更新処理
#### 勾配降下法の考え方
#### バックプロパゲーションの処理
#### Onepoint NeuralNetToolsのインストール
### ニューラルネットワークでワインの評価を分類する

# Appendix 資料
## 関数リファレンス
### 統計分析に関連する関数
### 数値の処理を行う関数
### ベクトルの処理を行う関数
### データフレームの処理を行う関数
### グラフ関係の関数
## 統計用語集
## 用語索引
